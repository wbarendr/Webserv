#include "VirtualServer.hpp"
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>
#include "Error.hpp"
#include "utils.hpp"
#include "Server.hpp"


VirtualServer::VirtualServer(t_v_context &v_context, std::string host, t_v_server_conf conf) 
: m_host(host),
m_socket(-1),
m_configs(conf),
m_sockaddr(),
m_v_context(v_context)
{
	memset(&this->m_sockaddr, 0, sizeof(this->m_sockaddr));//fill
}

void	VirtualServer::setAddr() {
	std::string	config_addr =  this->m_configs.m_directives["listen"];
	size_t	c = config_addr.find(':', 0);
	std::string port = c == std::string::npos ? config_addr : config_addr.substr(c + 1, config_addr.size() - c);
	if (port.empty() || port.find_first_not_of("0123456789", 0) != std::string::npos)
		throw serverError("server init", "invalid port");
	this->m_sockaddr.sin_family = AF_INET;
	//std::cout<<"inet_() "<<config_addr.substr(0, c)<<std::endl;
	this->m_sockaddr.sin_addr.s_addr = inet_addr(config_addr.substr(0, c).c_str());
	//std::cout<<"inet_ntoa()"<<inet_ntoa(this->m_sockaddr.sin_addr)<<std::endl;
	this->m_sockaddr.sin_port = hostToNetworkShort(ftAtoi(port.c_str()));
	memset(this->m_sockaddr.sin_zero, 0, sizeof(this->m_sockaddr.sin_zero));//fill
}

void	VirtualServer::init() {
	int	enable = 1;

	this->setAddr();
	if ((this->m_socket = socket(AF_INET, SOCK_STREAM, 0)) == -1)
		throw(serverError("socket", strerror(errno)));
	if (setsockopt(this->m_socket, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(int)) == -1)
		throw(serverError("setsockopt", strerror(errno)));
}

VirtualServer::t_v_server_conf	VirtualServer::*getVServerConf(std::string &) {
	return 0;
}

//VirtualContext


VirtualContext::VirtualContext() 
: m_port(-1), 
m_v_server_host(),  
m_catch_all(0)
{}

void	VirtualContext::setCatchAll() {
	for (t_v_server_host::iterator host = this->m_v_server_host.begin();
			host != this->m_v_server_host.end(); ++host) {
		if (!host->first.compare(0, 7, "0.0.0.0")) {
			this->m_catch_all = &host->second;
			return ;
		}
	}
}

VirtualContext::t_v_server *VirtualContext::getVirtualServer(std::string &host) {
		//std::cout<<"inet_ntoa"<<inet_ntoa(tmp->sin_addr)<<std::endl;
	(void)host;
	return 0;
}

VirtualContext::t_v_server *VirtualContext::getVirtualServer(std::string &host, struct sockaddr_storage const &client_addr) {
	struct sockaddr_in const *tmp = reinterpret_cast<struct sockaddr_in const *>(&client_addr);
	//
	//WIP
	std::string ip_port(inet_ntoa(tmp->sin_addr));
	ip_port.append(":");
	ip_port.append(sputnbr(this->m_port));

	std::cout<<"client ip:port "<<ip_port<<std::endl;
	std::cout<<"host request "<<host<<std::endl;
	std::vector<t_v_server>		*listener = 0;
	t_v_server_host::iterator	blocks = this->m_v_server_host.find(host);//doesnt work because host is one byte too long, needs to be fixed in RequestParser
	if (blocks == this->m_v_server_host.end()) {
		if (this->m_catch_all)
			listener = m_catch_all;
		else
			listener = &this->m_v_server_host.begin()->second; //WIP
	}
	else {
		listener = &blocks->second;
	}
	////WIP
	//for (std::vector<t_v_server>::iterator v_server = listener->begin();
	//		v_server != listener->end(); ++v_server) {
	//	// should return 0, but headers strings generated by RequestParser have an extra byte?
	//	if (host.compare(v_server->m_configs.m_directives["server_name"]) == 1) { 
	//		return (*v_server);
	//	}
	//}
	return &(*listener)[0];
}

VirtualContext::t_v_server *VirtualContext::getVirtualServer(int socket) {
	if (this->m_catch_all) {
		if ((*(this->m_catch_all))[0].m_socket)
			return &((*(this->m_catch_all))[0]);
		return 0;
	}
	for (t_v_server_host::iterator host = this->m_v_server_host.begin();
			host != this->m_v_server_host.end(); ++host) {
		if (host->second[0].m_socket == socket)
			return &host->second[0];
	}
	return 0;
}
